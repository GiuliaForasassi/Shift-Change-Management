\chapter{Modellazione del problema}\label{ch:chapter2}

\section{Introduzione al problema}
In questo capitolo si vuole spiegare le specifiche del problema preso in esame, introducendone prima i concetti principali e in seguito i dettagli implementativi della soluzione finale.

Il problema affrontato riguarda la \textbf{programmazione dei turni}, che è da sempre un'attività molto importante in qualunque settore lavorativo e in particolare in quello ospedaliero, per la gestione della sanità.

Fissato il numero del personale medico e il periodo di tempo in cui si vuole organizzare l'orario di lavoro, l'obbiettivo è quello di ottimizzare la gestione del cambio dei turni all'interno di un ospedale, cercando di soddisfare tutti i vincoli imposti dal problema.
Per trovare la soluzione ottima si è modellato il seguente problema come un \textbf{problema di programmazione lineare intera} in cui le variabili sono obbligate ad assumere solo valori interi, e la maggior parte di esse sono binarie.
Il programma riceve in input le seguenti tipologie di informazioni:
\begin{enumerate}
\item \textit{Informazioni generali}: dati che sono globali a tutte le settimane che compongono il periodo di tempo fissato, come per esempio i tipi di turni disponibili o il genere di contratto scelto;
\item \textit{Informazioni giornaliere}: dati specifici di ogni giorno, come le richieste di un singolo lavoratore per un dato giorno;
\item \textit{Informazioni storiche}: dati che riguardano la programmazione dei turni nelle settimane precedenti al periodo selezionato.
\end{enumerate}

In aggiunta a queste informazioni, per costruire il modello è stato necessario imporre alcuni vincoli, sia soft che hard, con lo scopo di soddisfarne un numero più alto possibile, e desiderando trovare una soluzione ammissibile al problema tale da soddisfare al meglio la maggior parte dei vincoli.
Nel prossimo capitolo verranno poi presentati alcuni esperimenti per analizzare l'efficienza e le prestazioni del modello al variare del numero del personale e delle settimane che compongono il periodo di pianificazione.

Di seguito verrà illustrato nel dettaglio il modello relativo al turnaggio degli infermieri, tenendo conto che tale modello non è restrittivo al solo personale infermieristico ma potrebbe essere tranquillamente applicato a casi simili come per i medici o altre figure di rilievo all'interno di un ospedale o in realtà lavorative diverse.

\section{Definizione del problema}
Il problema consiste nel definire la programmazione dei turni lavorativi di un numero fissato di infermieri nell'arco temporale scelto, avendo a disposizione varie tipologie di informazioni e con l'obbiettivo di soddisfare il maggior numero di vincoli possibili.

Sulla base di ciò, viene creato un modello del problema, usando sia variabili intere che intere binarie, con lo scopo di minimizzare il costo complessivo delle penalità dei vari vincoli, ovvero ciò che si deve pagare nel caso uno o più vincoli non siano soddisfatti.

\subsection{Informazioni generali}
Le informazioni generali presenti riguardano i dati che sono comuni a tutte le settimane che compongono il periodo di pianificazione scelto, e sono rappresentate dai seguenti elementi:
\begin{itemize}

\item \textit{Periodo complessivo}: il numero di settimane di cui è composto l'intervallo di tempo fissato;

\item \textit{Tipi di turni}: ogni giorno è possibile svolgere varie tipologie di turno che corrispondono a diversi momenti della giornata. Nell'esempio in questione vengono considerate 4 tipologie di turno: early (mattina), day (giorno), late (pomeriggio) e night (notte). Per ognuno di questi sono dati:
\begin{itemize}
\item il numero minimo di assegnamenti consecutivi possibili, cioè il numero minimo totale di turni che ogni infermiere, secondo il proprio contratto, deve svolgere;
\item una matrice delle successioni di turni proibiti, la quale, ad ogni infermiere, vieta di svolgere particolari successioni di turni nell'orario.
\end{itemize}

\item \textit{Infermieri}: per ogni infermiere si conosce il nome, l'identificativo, il tipo di contratto scelto e l'insieme delle competenze possedute;

\item \textit{Competenze}: lista di competenze che possono possedere gli infermieri. In particolare le competenze prese in considerazione nel seguente problema sono:
\begin{itemize}
\item head-nurse (capo infermiere);
\item nurse (infermiere regolare);
\item caretaker (?);
\item trainee (apprendista).
\end{itemize}

\item \textit{Tipo di contratto}: vi sono varie tipologie di contratto che ogni infermiere può avere, in questo problema abbiamo considerato i seguenti:
\begin{itemize}
\item full time;
\item part time;
\item a chiamata.
\end{itemize}
Ognuno di questi stabilisce dei limiti sulla distribuzione e sul numero di incarichi che si possono assegnare nel lasso di tempo selezionato. In dettaglio, contengono:
\begin{itemize}
\item il numero minimo e il numero massimo di assegnamenti possibili, cioè i limiti dei turni a cui un infermiere può essere assegnato nel periodo totale;
\item il numero minimo e il numero massimo di giorni lavorativi consecutivi, ovvero i limiti del numero di giorni contigui in cui l'infermiere lavora nel periodo complessivo;
\item il numero minimo e il numero massimo di giorni liberi consecutivi, cioè il numero più piccolo e più grande di giorni in cui l'infermiere può non lavorare;
\item il numero massimo di week-ends lavorativi;
\item un valore booleano che rappresenta la presenza del vincolo Week-end Completo nel contratto dell'infermiere, ovvero se devono essere penalizzati assegnamenti che prevedono che l'infermiere in questione lavori uno e un solo giorno nel fine settimana. 
\end{itemize}
\end{itemize}

\subsection{Informazioni giornaliere}
Le informazioni che possono variare da un giorno all'altro sono le seguenti:
\begin{itemize}
\item \textit{Requisiti necessari}: è dato, per ogni turno, per ogni competenza e per ogni giorno della settimana il numero minimo e ottimo di infermieri necessari per compiere il lavoro;
\item \textit{Richieste dell'infermiere}: ogni infermiere può esprimere il desiderio di non lavorare un dato giorno in uno specifico turno per problemi o impegni personali.
Nel caso nella richiesta fosse presente la parola speciale "Any" nel campo del turno, significa che l'infermiere vorrebbe non lavorare per l'intera giornata e quindi avere un giorno libero.
\end{itemize}

\subsection{Informazioni storiche}
Oltre a quanto visto in precedenza, è anche necessario tener conto anche delle informazioni storiche, che potrebbero essere presenti per il periodo in cui si vuole calcolare l'orario del personale, per determinare una soluzione accurata del problema.
In particolare queste sono rappresentate dalle condizioni a contorno, che vengono usate per controllare i vincoli riguardo agli assegnamenti di infermieri in giorni consecutivi, ed includono:
\begin{itemize}
\item i turni lavorati nell'ultimo giorno della settimana precedente al periodo scelto;
\item numero di turni di lavoro consecutivi dello stesso tipo, e il numero di turni di lavoro consecutivi in generale;
\item numero di giorni liberi consecutivi.
\end{itemize}

\subsection{Esempio}
Per avere una visione più chiara delle informazioni di cui abbiamo bisogno per fare la programmazione dell'orario ospedaliero si illustra di seguito un esempio.

\subsubsection*{Informazioni generali}
Supponiamo di voler pianificare l'orario lavorativo in un periodo di tempo pari a 1 settimana avendo a disposizione 5 infermieri, che possono avere 2 tipologie di competenze:

\begin{verbatim}
PERIODO: 1 SETTIMANA
NUMERO INFERMIERI = 5
COMPETENZE: 2
- HeadNurse
- Nurse
\end{verbatim}

Supponiamo di avere 2 tipologie di turno, e, per ognuno di questi, sono specificati il nome e il numero minimo e massimo di assegnazioni consecutive consentite.
Inoltre per ogni tipo di turno è data la successione dei turni proibiti, la quale specifica per ogni tipo di turno quelli che non possono essere successivi a questo.

\begin{verbatim}
TIPI DI TURNI = 3
- Early (min: 2, max: 5)
- Late (min: 2, max: 3)
- Night (min: 4, max: 5)
\end{verbatim}

\begin{verbatim}
SUCCESSIONE TURNI VIETATA
- Early: []
- Late: [Early]
- Night: [Early, Late]

\end{verbatim}

Inoltre, per ogni tipo di contratto, sono dati i seguenti dati:il numero minimo e massimo di assegnamenti possibile nel periodo selezionato, il numero minimo e massimo di giorni lavorativi consecutivi, il numero minimo e massimo di giorni liberi consecutivi, numero massimo di week-ends lavorativi e la presenza o l'assenza del week-end completo.

\begin{verbatim}
CONTRACT = 2
- Full time: (minAss: 15, maxAss: 22), (minLav: 3, maxLav: 5), 
				(minLib: 2, maxLib: 3), maxWknd: 2, WkndCom: True
				
- Part time: (minAss: 7, maxAss: 11), (minLav: 3, maxLav: 5), 
				(minLib: 3, maxLib: 5), maxWknd: 2, WkndCom: True
\end{verbatim}

Infine, vengono specificate le informazioni relative agli infermieri, ovvero il tipo di contratto e le competenze possedute.
\begin{verbatim}
INFERMIERI: 5
- Patrick: Full-time, [Head nurse, nurse]
- Andrea: Full-time, [Head nurse, nurse]
- Sara: Full-time, [Head nurse]
- Milena: Full-time, [Head nurse]
- Sofia: Full-time, [Nurse]
\end{verbatim}

\subsubsection*{Informazioni giornaliere}
A questo punto è necessario specificare i dati relativi ai requisiti necessari e alle richieste degli infermieri.

Per ogni tipo di turno, per ogni competenza vengono specificati il numero minimo e ottimo di infermieri necessari. Ovviamente questa informazione viene specificata per ogni giorno e per tutte le combinazioni tra il tipo di turno e la competenza.
Di seguito si riporta un esempio per il turno `Early' e la competenza `Head nurse'.

\begin{verbatim}
REQUISITI NECESSARI
- (Early, Head nurse, lun): (min: 1, opt:3)
- (Early, Head nurse, mar): (min: 2, opt:5)
- (Early, Head nurse, mer): (min: 3, opt:4)
- (Early, Head nurse, gio): (min: 6, opt:7)
- (Early, Head nurse, ven): (min: 1, opt:1)
- (Early, Head nurse, sab): (min: 1, opt:2)
- (Early, Head nurse, dom): (min: 1, opt:3)
\end{verbatim}

Inoltre, ogni infermiere può richiedere dei permessi: ovvero ognuno di loro può specificare il giorno e il turno in cui non vorrebbe lavorare. Inoltre, se dichiarato il turno `Any' l'infermiere vorrebbe l'intero giorno libero.

\begin{verbatim}
RICHIESTE INFERMIERI = 3
- Patrick: (Night, Sab)
- Andrea: (Early, Sab)
- Sara: (Any, Dom)
\end{verbatim}

\subsubsection*{Informazioni storiche}
Inoltre, come spiegato prima, vi sono delle informazioni precedenti al periodo selezionato.

\begin{verbatim}
STORIA
- Patrick: [numAss: 0, numWkndLav: 0, 
			ultimoTurno: Day, numAssCons: 0, 
			numLavCons = 2, numLibCons: 0]
			
- Andrea: [numAss: 0, numWkndLav: 0, 
			ultimoTurno: Early, numAssCons: 3, 
			numLavCons = 3, numLibCons: 0]
			
- Sara: [numAss: 0, numWkndLav: 0, 
		ultimoTurno: None, numAssCons: 0, 
		numLavCons = 0, numLibCons: 3]
		
- Milena: [numAss: 0, numWkndLav: 0, 
			ultimoTurno: Late, numAssCons: 1, 
			numLavCons = 4, numLibCons: 0]
			
- Sofia: [numAss: 0, numWkndLav: 0, 
		ultimoTurno: Day, numAssCons: 0, 
		numLavCons = 0, numLibCons: 1]
\end{verbatim}

\section{Vincoli}
In questo paragrafo verranno spiegati i vincoli relativi al problema di ottimizzazione in questione, alcuni dei quali sono \textit{hard} ovvero devono essere assolutamente rispettati, mentre gli altri sono \textit{soft}, ovvero si permette di violarli pagando però una penalità nella funzione obbiettivo.

Per maggior chiarezza si riporta di seguito la notazione usata per spiegare i vincoli dal punto di vista matematico:
\begin{itemize}
\item $I$: insieme di tutti gli infermieri;
\item $T$: insieme dei tipi di turni;
\item $G$: insieme dei giorni della settimana del periodo preso in considerazione;
\item $C$: insieme delle competenze degli infermieri;
\item $I_c$: insieme degli infermieri che hanno la competenza c;
\item $S_{VT}$: elenco di successioni vietate di turni;
\item $I_{cw}$: lista di infermieri che hanno il week-end completo, cioè devono lavorare sia sabato che domenica;
\item $G_S$: lista di tutti i sabati presenti nel periodo di pianificazione fissato;
\item $minConsLav_i$: numero minimo di giorni consecutivi in cui l'infermiere i deve lavorare secondo il contratto scelto;
\item $maxConsLav_i$: numero massimo di giorni consecutivi in cui l'infermiere può lavorare secondo il contratto scelto;
\item $minConsLib_i$: numero minimo di giorni consecutivi in cui l'infermiere i può avere giorno libero secondo il contratto scelto;
\item $maxConsLib_i$: numero massimo di giorni consecutivi in cui l'infermiere i può avere giorno libero secondo il contratto scelto;
\item $hTurniCons_i$: numero di turni consecutivi in cui l'infermiere i ha lavorato nei giorni precedenti al periodo selezionato;
\item $hLibCons_i$: numero di turni consecutivi in cui l'infermiere i ha avuto giorno libero nei giorni precedenti al periodo selezionato.
\end{itemize}

\subsection{Assegnamento di un singolo giorno}
Il vincolo \textit{hard} riguardo agli assegnamenti giornalieri impone che ogni infermiere possa fare al massimo un turno al giorno. Quindi, in altre parole, la somma dei turni fatti da ogni infermiere deve essere minore o uguale ad 1. Perciò si può scrivere matematicamente:
\begin{equation}
\sum_{t \in T} a_{i, t, g} \leq 1 ~~~ \forall i \in I ~~~ \forall g \in G
\end{equation}
dove $a_{i, t, g}$ è la \textbf{variabile binaria d'assegnamento} definita come segue:
\begin{equation}
\label{eq:varAssegnamento}
a_{i, t, g}=
\begin{cases}
1, & \text{se l'infermiere i è assegnato al turno t il giorno g,} \\
0, & \text{altrimenti.}
\end{cases}
\end{equation}

Si riporta il codice Python relativo al vincolo:
\begin{lstlisting}[language=Python]
model.addConstrs((quicksum(a[i, t, g] for t in T) <= 1 
	for i in I for g in G))
\end{lstlisting}


\subsection{Livelli minimi di personale}
Il seguente vincolo \textit{hard} impone che il numero di infermieri per ogni turno e per ciascuna competenza sia almeno pari al requisito minimo. \\
Matematicamente corrisponde a scrivere la seguente formula:
\begin{equation}
\sum_{i \in I_c} a_{i,t,g} \geq min_{t,c,g} ~~~ \forall t \in T ~~~ \forall c \in C ~~~ \forall g \in G
\end{equation}
dove $min_{t,c,g}$ è il numero minimo di infermieri necessari per la data competenza c a ricoprire il turno t, nel giorno g.

Quindi per ogni turno, per ogni giorno e per ogni competenza viene calcolato il numero di infermieri obbligando tale numero ad essere maggiore o uguale al numero minimo necessario, sempre per ogni turno, competenza e giorno.

Il codice Python corrispondente è il seguente:
\begin{lstlisting}[language=Python]
model.addConstrs((quicksum(a[i, t, g] for i in I[c]) 
			>= min[t, c, g] for t in T
							for g in G
							for c in C))
\end{lstlisting}

\subsection{Successioni di turni valide}
Infine, l'ultimo vincolo \textit{hard} impone che gli assegnamenti dei turni infermieristici in due giorni consecutivi devono appartenere alla successione legale stabilita.
Matematicamente si può scrivere:
\begin{equation}
\begin{split}
&a_{i, t_{a}, g} + a_{i, t_{b}, g+1} \leq 1 \\
&\forall i \in I ~~~ \forall g \in \{0,...,|G| - 2\} ~~~ \forall ~ t_{a}, t_{b} \in T ~~~ tale ~ che ~ (t_{a}, t_{b}) \in S_{VT} \\
\end{split}
\end{equation}

Cioè, in altre parole, un infermiere non può lavorare nei turni $t_{a}$ e $t_{b}$ in due giorni consecutivi della settimana se questa coppia di turni ($t_{a}$, $t_{b}$) appartiene alla successione di turni proibita, dove ricordiamo che le successioni di turni proibite sono le seguenti:
\begin{itemize}
\item (Late: (Early, Day))
\item (Night: (Early, Day, Late))
\end{itemize}
Quindi, si può vedere che è possibile fare due o più notti di seguito.

Il codice Python corrispondente è il seguente:
\begin{lstlisting}[language=Python]
model.addConstrs(((a[i, ta, g] + a[i, tb, g+1] <= 1)
                for i in I
                for g in range(len(G)-1) 
                for ta in T
                for tb in T
                if (ta, tb) in Svt)
\end{lstlisting}

\subsection{Personale insufficiente per copertura ottimale}
Il seguente vincolo \textit{soft} ha l'obbiettivo di fare in modo che il numero di infermieri per ogni turno e per ciascuna competenza sia il più vicino possibile al requisito ottimale. 
Gli infermieri extra, cioè quelli al di sopra del valore ottimale, contrariamente a quelli mancanti, non sono considerati nel costo.
Si definiscono:
\begin{itemize}
\item $s^{(1)}_{t, c, g}$: variabile intera che, dati turno, competenza e giorno, rappresenta la penalità del vincolo;
\item $opt_{t,c,g}$: numero ottimo di infermieri dati turno, competenza e giorno;
\item $S^{(1)}$: penalità complessiva che, moltiplicata per il peso, deve essere pagata come costo. In altre parole, è data dalla somma di tutte le singole penalità $s^{(1)}_{t, c, g}$.
\end{itemize}

L'idea che sta alla base di questo vincolo è confrontare la quantità di infermieri assegnati con il valore ottimo per ogni turno e per ogni competenza.
Quindi, fissati il turno $t$, il giorno $g$ e la competenza $c$, vi sono due casi possibili:
\begin{enumerate}
\item se il totale di assegnamenti fatti è maggiore o uguale del valore ottimo corrispondente allora non si dovrà pagare alcuna penalità, cioè:
\begin{equation}
\sum_{i \in I_c} a_{i, t, g} \geq opt_{t,c,g} \Longrightarrow s^{(1)}_{t, c, g} = 0
\end{equation}
\item altrimenti la penalità da pagare è data dalla differenza tra il valore ottimo e gli assegnamenti fatti, cioè: 
\begin{equation}
\sum_{i \in I_c} a_{i, t, g} < opt_{t,c,g} \Longrightarrow s^{(1)}_{t, c, g} = opt_{t,c,g} - \sum_{i \in I_c} a_{i, t, g}
\end{equation}
\end{enumerate}

E quindi chiamando $z = opt_{t,c,g} - \sum_{i \in I_c} a_{i, t, g}$ segue:
\begin{equation}
\begin{split}
z \leq 0 &\Longrightarrow s^{(1)}_{t, c, g} = 0 \\
z > 0 &\Longrightarrow s^{(1)}_{t, c, g} = z \\
\end{split}
\end{equation}

Da cui si può vedere che:
\begin{equation}
\label{eq:maxS1}
s^{(1)}_{t, c, g} = max(0, z)
\end{equation}
Quindi, considerando che $s^{(1)}_{t, c, g}$ viene minimizzato dall'ottimizzatore, per ottenere la (\ref{eq:maxS1}) si impongono i due vincoli:
\begin{equation}
\begin{split}
s^{(1)}_{t, c, g} &\geq 0 \\
s^{(1)}_{t, c, g} &\geq z \\
\end{split}
\end{equation}

Riassumendo quanto detto sopra, possiamo scrivere:
\begin{gather}
\begin{aligned}
s^{(1)}_{t, c, g} &\geq 0 ~~~ \forall t \in T ~~~ \forall c \in C ~~~ \forall g \in G \\
s^{(1)}_{t, c, g} &\geq opt_{t,c,g} - \sum_{i \in I_c} a_{i, t, g} ~~~ \forall c \in C ~~~ \forall t \in T ~~~ \forall g \in G \\
S^{(1)}  &=  \sum_{t \in T} \sum_{c \in C} \sum_{g \in G} s^{(1)}_{t, c, g} \\
\end{aligned}
\end{gather}

Il codice Python corrispondente è il seguente:
\begin{lstlisting}[language=Python]
s1 = model.addVars(T, C, G, vtype=GRB.INTEGER)

model.addConstrs(s1[t, c, g] >= 0 
				for t in T for c in C for g in G)

model.addConstrs((s1[t, c, g] >= (opt[t, c, g] 
	- quicksum(a[i, t, g] for i in I[c])) 
   				 for c in C for t in T for g in G)

S1 = quicksum(s1[t, c, g] 
				  for t in T for c in C for g in G)
\end{lstlisting}


\subsection{Assegnamenti consecutivi}
Tale vincolo \textit{soft} ha lo scopo di far rispettare il numero minimo e massimo di assegnamenti consecutivi che è possibile fare. Sia nel caso del limite minimo che nel caso del limite massimo è necessario tener conto, se esistono, delle assegnazioni fatte nel periodo precedente a quello selezionato.

\subsubsection{Limite minimo}
L'assegnazione di un infermiere in più giorni lavorativi consecutivi deve essere maggiore o uguale al numero minimo previsto nel contratto di quest'ultimo. Per realizzare questo vincolo l'idea è quella di confrontare i giorni in cui l'infermiere ha lavorato con quelli in cui avrebbe dovuto lavorare per soddisfare tale vincolo. Si definiscono:
\begin{itemize}
\item $L_{i, g}$: variabile binaria che tiene conto se l'infermiere ha lavorato o meno quel giorno, cioè:
\begin{equation}
\label{eq:varLavorato}
L_{i, g}=
\begin{cases}
1, & \text{se l'infermiere i ha lavorato il giorno g,} \\
0, & \text{altrimenti.}
\end{cases}
\end{equation}
\item $L_{i, g}^R$: variabile binaria che ci dice se l'infermiere avrebbe dovuto lavorare quel giorno secondo l'assegnamento che era stato programmato, cioè:
\begin{equation}
\label{eq:varAvrebbeDovutoLavorare}
L_{i, g}^R=
\begin{cases}
1, & \text{se l'infermiere i avrebbe dovuto lavorare il giorno g,} \\
0, & \text{altrimenti.}
\end{cases}
\end{equation}
\item $S^{(2)}_{min}$: penalità complessiva riguardo al limite minimo che, moltiplicata per il peso corrispondente, deve essere pagata. Essa è data dalla differenza tra i giorni in cui l'infermiere avrebbe dovuto lavorare per non violare il suddetto vincolo e quelli effettivamente lavorati.
\end{itemize}

Quindi vediamo in dettaglio quali vincoli è necessario imporre per gestire il numero minimo di assegnamenti consecutivi:
\begin{itemize}

\item Se l'infermiere $i$ è stato assegnato al turno $t$ nel giorno $g$, si vuole che la variabile $L_{i, g}$ valga 1; questo corrisponde a scrivere:
\begin{equation}
a_{i, t, g} = 1 \Longrightarrow\ L_{i, g} = 1
\end{equation}
Quindi fissato l'infermiere $i$, il turno $t$, e il giorno $g$, si ha:
\begin{equation}
L_{i, g} \geq a_{i, t, g}
\end{equation}

%\item Un turno di notte corrisponde a lavorare per due giorni consecutivi.
%Quindi se il giorno $g$ l'infermiere $i$ è stato assegnato in un turno notturno, il giorno seguente deve essere contato come lavorato:\\
%\begin{equation}
%se ~ a_{i, t_{notte}, g} = 1 \Longrightarrow\ L_{i, g+1} = 1
%\end{equation}
%Fissati $i$ e $g$, possiamo scrivere:
%\begin{equation}
%L_{i, g+1} \geq a_{i, t_{notte}, g}
%\end{equation}

\item È necessario, però, assicurarsi che $L_{i, g}$ valga 0 quando non sono stati fatti assegnamenti.
\begin{equation}
a_{i, t, g} = 0 \Longrightarrow\ L_{i, g} = 0
\end{equation}
Questo corrisponde ad imporre il seguente vincolo:
\begin{equation}
L_{i, g} \leq \sum_{t \in T} a_{i, t, g} 
\end{equation}

%a_{i, t_{notte}, g-1}

\item Se l'infermiere $i$ ha lavorato il giorno $g$ come richiesto dal vincolo, la penalità non deve essere pagata, quindi la differenza tra i giorni che ha lavorato e quelli in cui avrebbe dovuto lavorare per non violare il vincolo vale 0, cioè:
\begin{equation}
L_{i, g} = 1 \Longrightarrow\ L_{i, g}^R - L_{i, g} = 0
\end{equation}
Quindi si ha che in generale deve valere che:
\begin{equation}
L_{i, g}^R \geq ~ L_{i, g}
\end{equation}

\item Poiché è necessario che l'infermiere ricopra il numero minimo di assegnamenti previsti, dobbiamo imporre che, una volta che ha iniziato a lavorare, continui per almeno il numero minimo di turni richiesti. Inoltre è necessario far si che la variabile $L_{i, g}^R$ indichi i giorni in cui l'infermiere $i$ avrebbe dovuto lavorare.
Fissato l'infermiere $i$ e considerando l'insieme delle relative variabili $L_{i, g}^R$, ciò che ci interessa sono le transizioni dei valori da 0 a 1 le quali indicano che l'infermiere $i$ dovrebbe iniziare a lavorare per non violare il vincolo. 
Quindi, sia $j \in \{g,.., g + minConsLav_i - 1\}$:\\
\begin{equation}
L_{i, g-1}^R = 0 \wedge L_{i, g}^R = 1 \Longrightarrow\ L_{i, j}^R = 1
\end{equation}
Dato l'infermiere $i$ e il giorno $g$, generalizzando, possiamo scrivere:
\begin{equation}
L_{i, g+n}^R \geq L_{i, g}^R - L_{i, g-1}^R
\end{equation}

\item Questo vincolo ha lo stesso scopo di quello sopra, però, prende in considerazione anche la storia precedente al periodo selezionato, se esiste.
Quindi, supponendo che vi siano giorni consecutivi appartenenti allo storico e che tale numero sia minore degli assegnamenti consecutivi minimi per quell'infermiere, bisogna imporre che, il primo giorno del periodo scelto per la pianificazione, l'infermiere $i$ deve lavorare per rispettare il vincolo. Quindi, fissato $i$, segue che:
\begin{equation}
0 < hTurniCons_i < minConsLav_i \Longrightarrow\ L_{i, 0}^R = 1
\end{equation}

\item Ovviamente è necessario garantire che quanto detto sopra valga anche per i giorni successivi al primo. \\
Sia  $j \in \{1,.., minConsLav_i - hTurniCons_i - 1\}$:\\
\begin{equation}
L_{i, 0}^R + L_{i, g}^R <  minConsLav_i \Longrightarrow\ L_{i, j}^R = 1
\end{equation}
Quindi, in questo caso, l'infermiere $i$ dovrebbe lavorare anche i giorni seguenti:
\begin{equation}
L_{i, n}^R \geq L_{i, 0}^R
\end{equation}
\end{itemize}

Riassumendo quanto detto sopra, possiamo scrivere:
\begin{gather}
\begin{aligned}
L_{i, g} &\geq a_{i, t, g} ~~~ \forall i \in I ~~~ \forall t \in T ~~~ \forall g \in G \\
L_{i, g} &\leq \sum_{t \in T} a_{i, t, g} ~~~ \forall i \in I ~~~ \forall g \in \{1,...,|G| - 1\} \\
L_{i, g}^R &\geq L_{i, g} ~~~ \forall i \in I ~~~ \forall g \in G \\
L_{i, g+n}^R &\geq L_{i, g}^R - L_{i, g-1}^R ~~~ \forall i \in I ~~~ \forall n \in \{0,...,minConsLav_i - 1\} ~~~ \forall g \in \{1,...,|G| - n - 1\} \\
L_{i, 0}^R &= 1 ~~~ \forall i \in I ~ tale ~ che ~ 0 < hTurniCons_i < minConsLav_i \\
L_{i, n}^R &\geq L_{i, 0}^R ~~~ \forall i \in I ~~~ \forall n \in \{1,...,minConsLav_i - hTurniCons_i - 1\} \\
S^{(2)}_{min} &= \sum_{i \in I} \sum_{g \in G} L_{i, g}^R - L_{i, g} \\
\end{aligned}
\end{gather}

%L_{i, g+1} &\geq a_{i, t_{notte}, g} ~~~ \forall i \in I ~~~ \forall g \in \{0,...,|G| - 2\} \\
%+ a_{i, t_{notte}, g-1} 
 
Il codice Python corrispondente è il seguente:
\begin{lstlisting}[language=Python]
L = model.addVars(I, G, vtype=GRB.BINARY)

LR = model.addVars(I, G, vtype=GRB.BINARY)

model.addConstrs(L[i, g] >= a[i, t, g]
            for i in I
            for t in T
            for g in G)

model.addConstrs(L[i, g] <= 
		quicksum(a[i, t, g] for t in T)
            for i in I
            for g in range(1, len(G)))

model.addConstrs(LR[i, g] >= L[i, g] for i in I for g in G)

model.addConstrs(LR[i, g+n] >= 
		(LR[i, g] - LR[i, g-1])
            for i in I
            for n in range(0, minConsLav[i])
            for g in range(1, len(G) - n))

model.addConstrs(LR[i, n] >= LR[i, 0]
            for i in I
            for n in range(1, minConsLav[i] - hTurniCons[i]))

model.addConstrs(LR[i, 0] == 1
            for i in I
            if 0 < hTurniCons[i] < minConsLav[i])

S2_min = quicksum(LR[i, g] - L[i, g] for i in I for g in G)

\end{lstlisting}

\subsubsection{Limite massimo}
L'assegnazione di un infermiere in più giorni lavorativi consecutivi deve essere minore o uguale al numero massimo previsto nel contratto di quest'ultimo. 
In questo caso si deve pagare la penalità per gli assegnamenti in eccesso, cioè quando il numero di assegnamenti consecutivi di ogni infermiere è maggiore del limite previsto.
Si definiscono:
\begin{itemize}
\item $s^{(2)}max_{i, g}$: variabile binaria che indica la penalità per l'infermiere $i$ nel giorno $g$ nel caso il vincolo non sia rispettato;
\item $S^{(2)}_{max}$: penalità complessiva riguardo al limite massimo che, moltiplicata per il peso corrispondente, deve essere pagata. Questa è data dalla somma di tutte le singole penalità $s^{(2)}max_{i, g}$.
\end{itemize}

Analizziamo nel dettaglio i vincoli necessari per rispettare il limite massimo:
\begin{itemize}

\item L'idea è quella di confrontare il numero di giorni effettivamente lavorati dall'infermiere $i$ con il relativo limite massimo. Quindi, fissati...vi sono due situazioni possibili:
\begin{enumerate}
\item  se il totale di giorni consecutivi lavorati è minore o uguale al limite massimo corrispondente allora non si dovrà pagare alcuna penalità, cioè:
\begin{equation}
\sum_{j=g-maxConsLav_i}^g L_{i, j} \leq maxConsLav_i \Longrightarrow\ s^{(2)}max_{i, g} = 0
\end{equation}
\item altrimenti la penalità da pagare è data dalla differenza tra il valore massimo e i giorni consecutivi effettivamente lavorati, cioè:
\begin{equation}
\sum_{j=g-maxConsLav_i}^g L_{i, j} > maxConsLav_i \Longrightarrow\ s^{(2)}max_{i, g} = \sum_{j=g-maxConsLav_i}^g L_{i, g} - maxConsLav_i
\end{equation}
\end{enumerate}
E quindi chiamando $ z = \sum_{j=g-maxConsLav_i}^g L_{i, g} - maxConsLav_i$ segue:
\begin{equation}
\begin{split}
z \leq 0 &\Longrightarrow\ s^{(2)}max_{i, g} = 0 \\
z > 0 &\Longrightarrow\ s^{(2)}max_{i, g} = z \\
\end{split}
\end{equation}
Da cui si può vedere che:
\begin{equation}
\label{eq:maxS2}
s^{(2)}max_{i, g} = max(0, z)
\end{equation}
Quindi, considerando che $s^{(2)}max_{i, g}$ viene minimizzato nella funzione obbiettivo, per ottenere la (\ref{eq:maxS2}) si impongono i due vincoli:
\begin{equation}
\begin{split}
s^{(2)}max_{i, g} &\geq 0 \\
s^{(2)}max_{i, g} &\geq z \\
\end{split}
\end{equation}
Questo corrisponde ad imporre i seguenti vincoli:
\begin{equation}
\begin{split}
s^{(2)}max_{i, g} &\geq 0\\
s^{(2)}max_{i, g} &\geq (\sum_{j=g-maxConsLav_i}^g L_{i, j}) - maxConsLav_i\\
\end{split}
\end{equation}
Si può notare che, però, il primo vincolo scritto è ridondante in quanto $s^{(2)}max_{i, g}$ è una variabile binaria. Perciò basta imporre il secondo vincolo.

Possiamo inoltre osservare che questi due vincoli definisco le penalità che posso determinare subito guardando solo gli assegnamenti fatti (infatti trattano gli indici che vanno da $maxConsLav$ in poi), mentre quelle che verranno spiegate di seguito dipendono dalla storia precedente (riguardano i primi giorni del nuovo periodo).

\item A questo punto è necessario tener conto delle informazioni storiche precedenti al periodo selezionato, mediante le quali ci si accorge quando eventualmente si dovrebbe iniziare a pagare la penalità. Fissato $i$, e sia $k = maxConsLav_i - hTurniCons_i$sono possibili le seguenti situazioni:
\begin{enumerate}
\item Se la somma tra i giorni consecutivi lavorati nello storico e i giorni consecutivi lavorati all'inizio del nuovo periodo è minore o uguale del numero massimo di giorni consecutivi lavorativi che è possibile fare per ogni infermiere, allora la penalità sarà nulla. Cioè:
\begin{equation}
\begin{split}
hTurniCons_i + \sum_{g=0}^k L_{i, g} \leq maxConsLav_i \Longrightarrow s^{(2)}max_{i, k} = 0 
\end{split}
\end{equation}

\item Se la somma tra i giorni consecutivi lavorati nello storico e i giorni consecutivi lavorati all'inizio del nuovo periodo è maggiore del numero massimo di giorni consecutivi lavorativi che è possibile fare per ogni infermiere, allora è necessario pagare una penalità che è data dalla differenza tra quelli fatti (nel nuovo periodo e nello storico) e il numero massimo corrispondente. Cioè:
\begin{equation}
\begin{split}
hTurniCons_i + \sum_{g=0}^k L_{i, g} > maxConsLav_i \Longrightarrow s^{(2)}max_{i, k} = 1
\end{split}
\end{equation}
\end{enumerate}
Quindi, è necessario imporre:
\begin{equation}
\begin{split}
s^{(2)}max_{i, k} &\geq hTurniCons_i - maxConsLav_i + \sum_{g = 0}^{k} L_{i, g}
\end{split}
\end{equation}

\item Nel caso in cui nel vincolo sopra si deve pagare per il giorno di indice $maxConsLav_i - hTurniCons_i$, allora si deve imporre un ulteriore vincolo che consenta di continuare a pagare dopo aver iniziato a pagare la prima volta, dall'indice $maxConsLav_i - hTurniCons_i + 1$ in poi.
In altre parole, considerando un giorno $g$, se questo è lavorato dall'infermiere e il giorno precedente è stata pagata la penalità in quanto il vincolo non è stato rispettato, allora in questo caso la penalità del giorno $g$ deve valere 1.
Quindi, sia $g \in \{maxConsLav_i - hTurniCons_i + 1,...,maxConsLav_i\}$
\begin{equation}
s^{(2)}max_{i, g-1} = 1 \wedge L_{i, g} = 1 \Longrightarrow s^{(2)}max_{i, g} = 1
\end{equation}
Poiché la somma di $L_{i, g}$ e $s^{(2)}max_{i, g-1}$ restituisce un numero intero pari a 2, è necessario considerare la seguente quantità:\\
$L_{i, g} - s^{(2)}max_{i, g-1} - 1$
Quindi è necessario imporre il seguente vincolo:
\begin{equation}
s^{(2)}max_{i, g} \geq L_{i, g} + s^{(2)}max_{i, g-1} - 1
\end{equation}
Si avrebbe potuto considerare la moltiplicazione tra $L_{i, g}$ e $s^{(2)}max_{i, g-1}$, ma in questo modo il vincolo sarebbe diventato quadratico, e quindi più complicato da risolvere.
\end{itemize}

Riassumendo quanto detto sopra, possiamo scrivere:
\begin{gather}
\begin{aligned}
s^{(2)}max_{i, g} &\geq 0 ~~~ \forall i \in I ~~~ \forall g \in G \\
s^{(2)}max_{i, g} &\geq (\sum_{j=g - maxConsLav_i}^{g} L_{i, j}) - maxConsLav_i  \\
& \forall i \in I ~~~ \forall g \in \{maxConsLav_i,...,|G| - 1\} \\
s^{(2)}max_{i, k} &\geq hTurniCons_i - maxConsLav_i + \sum_{g = 0}^{k} L_{i, g} ~~~ \forall i \in I \\
s^{(2)}max_{i, g} &\geq L_{i, g} + s^{(2)}max_{i, g-1} - 1\\ 
\forall i \in I ~~~ \forall g \in &\{k + 1,...,maxConsLav_i - 1\} \\
S^{(2)}_{max} &= \sum_{i \in I} \sum_{g \in G} s^{(2)}max_{i, g} \\
\end{aligned}
\end{gather}

Il codice Python corrispondente è il seguente:
\begin{lstlisting}[language=Python]
s2_max = model.addVars(I, G, vtype=GRB.BINARY)

model.addConstrs(s2_max[i, g] >= 0 for i in I for g in G)

model.addConstrs((s2_max[i, g] >= (quicksum(L[i, j] 
	for j in range(g - maxConsLav[i], g+1)) - maxConsLav[i]))
                     for i in I
                     for g in range(maxConsLav[i], len(G)))

for i in I:
	if hTurniCons[i] > 0:
		model.addConstr(s2_max[i, maxConsLav[i] - hTurniCons[i]] >= 
			(hTurniCons[i] - maxConsLav[i] + quicksum(L[i, g] 
			for g in range(0, maxConsLav[i] - hTurniCons[i] + 1)))
			
		model.addConstrs((s2_max[i, d] >= 
		(L[i, d] + s2_max[i, d-1] - 1) 
		for d in range(maxConsLav[i] - hTurniCons[i] + 1,  maxConsLav[i])))
                      
S2_max = quicksum(s2_max[i, g] for i in I for g in G)
\end{lstlisting}


\subsection{Giorni liberi consecutivi}
Il seguente vincolo \textit{soft} impone di rispettare il numero minimo e massimo di giorni liberi consecutivi. Anche in questo caso vengono presi in considerazione le condizioni a contorno che riguardano la storia precedente al periodo di pianificazione selezionato. La penalità per ogni giorno extra o mancante viene moltiplicata per il peso corrispondente e aggiunta alla funzione obbiettivo.

\subsubsection{Limite minimo}
Il numero di giorni liberi consecutivi che ogni infermiere può prendere deve essere maggiore o uguale al numero minimo dei giorni liberi che gli spetterebbero secondo le regole del suo contratto. Si definiscono:
\begin{itemize}
\item $O_{i,g}^R$: variabile binaria che tiene conto se l'infermiere avrebbe dovuto avere giorno libero, cioè:
\begin{equation}
\label{eq:varStarbbeACasa}
O_{i,g}^R=
\begin{cases}
1, & \text{se l'infermiere i avrebbe dovuto riposarsi il giorno g,} \\
0, & \text{altrimenti.}
\end{cases}
\end{equation}
\item $S^{(3)}_{min}$: penalità complessiva riguardo al limite minimo che, moltiplicata per il peso corrispondente, deve essere pagata.
\end{itemize}

Per semplicità di lettura chiamiamo $O_{i, g} = (1-L_{i, g})$.

Analizziamo i vincoli uno ad uno.
\begin{itemize}
\item Se l'infermiere $i$ ha avuto giorno libero il giorno $g$ come richiesto dal vincolo, la penalità non deve essere pagata, quindi la differenza tra i giorni che avrebbe dovuto avere giorno libero e quelli in cui effettivamente l'ha avuto deve fare 0, cioè:
\begin{equation}
O_{i,g} = 1 \Longrightarrow O_{i,g}^R - O_{i,g} = 0
\end{equation}
Quindi si ha che in generale deve valere che:
\begin{equation}
O_{i,g}^R \geq O_{i,g}
\end{equation}

\item Poiché, è necessario che l'infermiere abbia un numero minimo di giorni liberi previsti, dobbiamo imporre che, una volta che ha iniziato a non lavorare, continui per almeno il numero minimo di turni richiesti.
Fissato l'infermiere $i$  e considerando l'insieme delle relative variabili $O_{i,g}^R$, ciò che ci interessa sono le transazioni dei valori da 0 a 1, le quali indicano che l'infermiere $i$ avrebbe dovuto iniziare a prendere giorni liberi per non violare il vincolo. Quindi, sia $j \in \{g,...,g + minConsLib_i - 1\}$:
\begin{equation}
O_{i,g-1}^R = 0 \wedge O_{i,g}^R = 1 \Longrightarrow O_{i,j}^R = 1
\end{equation}
Quindi, generalizzando, possiamo scrivere:
\begin{equation}
O_{i,g+n}^R \geq O_{i,g}^R - O_{i,g-1}^R
\end{equation}

\item Questo vincolo prende in considerazione anche la storia precedente al periodo, se esiste. Quindi, supponendo che vi siano giorni consecutivi liberi appartenenti allo storico e che tale numero sia minore di quelli consecutivi minimi per quell'infermiere, bisogna imporre che, il primo giorno del periodo, l'infermiere $i$ non deve lavorare. 
\begin{equation}
0 < hLibCons_i < minConsLib_i \Longrightarrow O_{i,0}^R = 1
\end{equation}

\item Ovviamente è necessario garantire che quanto detto sopra valga anche per i giorni successivi al primo. Sia $j \in \{1,..., minConsLib_i - hLibCons_i - 1\}$
\begin{equation}
O_{i,0}^R + O_{i,g}^R < minConsLib_i \Longrightarrow  O_{i,j}^R = 1
\end{equation}
Quindi, in questo caso, l'infermiere $i$, dovrebbe avere libero anche i giorni seguenti:
\begin{equation}
O_{i,n}^R \geq O_{i,0}^R
\end{equation}
\end{itemize}

Riassumendo si ha:
\begin{gather}
\begin{aligned}
O_{i,g}^R &\geq (1 - L_{i,g}) ~~~ \forall i \in I ~~~ \forall g \in G \\
O_{i,g+n}^R &\geq (O_{i,g}^R - O_{i,g-1}^R) ~~~ \forall i \in I ~~~ \forall n \in \{0,...,minConsLib_i - 1\} ~~~ \forall g \in \{1,...,|G| - n - 1\} \\
O_{i,0}^R &= 1 ~~~ \forall i \in I ~~~ tale ~ che ~ 0 < hLibCons_i < minConsLib_i \\
O_{i,n}^R &\geq O_{i,0}^R ~~~ \forall i \in I ~~~ \forall n \in \{0,...,minConsLib_i - hLibCons_i - 1\} \\
S^{(3)}_{min} &= \sum_{i \in I} \sum_{g \in G} O_{i,g}^R - (1 - L_{i,g}) \\
\end{aligned}
\end{gather}

Il codice Python corrispondente è il seguente:
\begin{lstlisting}[language=Python]
OR = model.addVars(I, G, vtype=GRB.BINARY)

model.addConstrs(OR[i, g] >= (1 - L[i, g])
             for i in I
             for g in G)

model.addConstrs(OR[i, g+n] >= (OR[i, g] - OR[i, g-1]])
             for i in I
             for n in range(0, minConsLib[i])
             for g in range(1, len(G) - n))

model.addConstrs(OR[i, n] >= OR[i, 0]
             for i in I
             for n in range(0, minConsLib[i] - hLibCons[i]))

model.addConstrs(OR[i, 0] == 1
             for i in I
             if 0 < hLibCons[i] < minConsLib[i])

S3_min = quicksum(OR[i, g] - (1 - L[i, g])
                        for i in I
                        for g in G)
\end{lstlisting}


\subsubsection{Limite massimo}
Il numero dei giorni liberi consecutivi associato ad ogni infermiere deve essere minore o uguale al numero massimo di giorni liberi consecutivi disponibili.
Si definiscono:
\begin{itemize}
\item $s^{(3)}max_{i, g}$: variabile binaria che indica la penalità per l'infermiere $i$ nel giorno g, nel caso il vincolo non sia rispettato;
\item $S^{(3)}_{max}$: penalità complessiva riguardo al limite massimo, che moltiplicata per il peso corrispondente, deve essere pagata.
Questa è data dalla somma di tutte le singole penalità $s^{(3)}max_{i, g}$.
\end{itemize}

Analizziamo nel dettaglio i vincoli necessari per rispettare il limite massimo:
\begin{itemize}
\item È necessario confrontare il numero di giorni effettivamente liberi dell'infermiere $i$ con il relativo limite massimo. Quindi, fissati $i$ e $g$, vi sono due casi possibili:
\begin{enumerate}
\item se il totale dei giorni consecutivi non lavorati è minore o uguale al limite massimo corrispondente, allora non si dovrà pagare alcuna penalità, cioè:
\begin{equation}
\sum_{j=g-maxConsLib_i}^g O_{i, j} \leq maxConsLib_i \Longrightarrow s^{(3)}max_{i, g} = 0
\end{equation}
\item altrimenti, la penalità da pagare è data dalla differenza tra il valore massimo e i giorni liberi consecutivi effettivi, cioè:
\begin{equation}
\sum_{j=g-maxConsLib_i}^g O_{i, j} > maxConsLib_i \Longrightarrow s^{(3)}max_{i, g} = \sum_{j=g-maxConsLib_i}^g O_{i, g} - maxConsLib_i
\end{equation}
\end{enumerate}
E quindi chiamando $z = \sum_{j=g - maxConsLib_1} O_{i, j} - maxConsLib_i$, segue:
\begin{equation}
\begin{split}
z \leq 0 &\Longrightarrow s^{(3)}max_{i, g} = 0\\
z > 0 &\Longrightarrow s^{(3)}max_{i, g} = z\\
\end{split}
\end{equation}
Da cui si può vedere che:
\begin{equation}
s^{(3)}max_{i, g} = max(0, z)
\end{equation}
Quindi da questo segue che:
\begin{equation}
\begin{split}
s^{(3)}max_{i, g} &\geq 0\\
s^{(3)}max_{i, g} &\geq z\\
\end{split}
\end{equation}
Quindi bisogna imporre i seguenti vincoli:
\begin{equation}
\begin{split}
s^{(3)}max_{i, g} &\geq 0\\
s^{(3)}max_{i, g} &\geq \sum_{j=g-maxConsLib_i} O_{i, j} - maxConsLib_i\\
\end{split}
\end{equation}
Si può notare, però, che il primo vincolo è ridondante in quanto $s^{(3)}max_{i, g}$ è una variabile binaria. Perciò basta imporre solo il secondo vincolo.

Come nel vincolo precedente, adesso si deve gestire le informazioni legate alla storia.

\item Fissato $i$, sono possibili le seguenti situazioni:
\begin{enumerate}
\item Se la somma tra i giorni liberi consecutivi dello storico e quelli fatti all'inizio del nuovo periodo è minore o uguale al numero massimo di quelli che sono possibili fare da ogni infermiere, allora la penalità sarà nulla. Cioè:
\begin{equation}
hLibCons_i + \sum_{g=0}^k O_{i, g} \leq maxConLib_i \Longrightarrow s^{(3)}max_{i, k} = 0
\end{equation}
dove $k = maxConLib_i - hLibCons_i$

\item Se, invece, tale numero è maggiore del numero massimo di giorni liberi consecutivi possibili, allora è necessario pagare una panalità definita come segue:
\begin{equation}
hLibCons_i + \sum_{g=0}^k O_{i, g} > maxConLib_i \Longrightarrow s^{(3)}max_{i, k} = 1
\end{equation}
\end{enumerate}
Quindi è necessario imporre:
\begin{equation}
s^{(3)}max_{i, k} \geq + hLibCons_i - maxConLib_i + \sum_{g=0}^k O_{i, g}
\end{equation}

\item Nel caso in cui il vincolo soprastante deve essere pagato per il giorno di indice $k = maxConLib_i - hLibCons_i$, allora si deve imporre un ulteriore vincolo che consenta di continuare a pagare per i giorni successivi.
Cioè, considerando un giorno $g$, se questo è giorno libero per l'infermiere e il giorno precedente è stata pagata penalità, allora la penalità del giorno $g$ deve valere 1. Sia $g \in \{k - 1,...,maxConLib_i\}$:
\begin{equation}
s^{(3)}max_{i, g-1} = 1 \wedge O_{i, g} = 1 \Longrightarrow s^{(3)}max_{i, g} = 1
\end{equation}
Poiché la somma di $O_{i, g}$ e $s^{(3)}max_{i, g-1}$ è pari a 2, è necessario considerare la seguente quantità:
\begin{equation}
s^{(3)}max_{i, g} \geq O_{i, g} + s^{(3)}max_{i, g-1} - 1
\end{equation}
\end{itemize}

Riassumendo si ha:
\begin{gather}
\begin{aligned}
s^{(3)}max_{i, g} &\geq 0 ~~~ \forall i \in I ~~~ \forall g \in G \\ 
s^{(3)}max_{i, g} &\geq (\sum_{j=g-maxConsLib_i}^g (1 - L_{i,j}) - maxConsLib_i) ~~~ \forall i \in I ~~~ \forall g \in \{maxConsLib_i,...,|G| - 1\} \\
s^{(3)}max_{i, k} &\geq hLibCons_i - maxConsLib_i + \sum_{g = 0}^{k} L_{i, g} ~~~ \forall i \in I \\
s^{(3)}max_{i, g} &\geq L_{i, g} + s^{(3)}max_{i, g-1} - 1\\ 
\forall i \in I ~~~ \forall g \in &\{k + 1,...,maxConsLib_i - 1\}\\
S^{(3)}_{max} &= \sum_{i \in I} \sum_{g \in G} s^{(3)}max_{i, g} \\
\end{aligned}
\end{gather}

Il codice Python corrispondente è il seguente:
\begin{lstlisting}[language=Python]
s3_max = model.addVars(I, G, vtype=GRB.BINARY)

model.addConstrs(s3_max[i, g] >= 0 for i in I for g in G)

model.addConstrs((s3_max[i, g] >= (quicksum(1 - L[i, j] 
		for j in range(g - maxConsLib[i], g+1)) - maxConsLib[i]))
                     for i in I
                     for g in range(maxConsLib[i], len(G)))

for i in I:
	if hLibCons[i] > 0:
		model.addConstr(s3_max[i, maxConsLib_i - hLibCons[i]] >= 
			(hLibCons[i] - maxConsLib_i + quicksum(L[i, g] 
			for g in range(0, maxConsLib_i - hLibCons[i] + 1)))
			
		model.addConstrs((s3_max[i, d] >= 
		(L[i, d] + s3_max[i, d-1] - 1) 
		for d in range(maxConsLib_i - hLibCons[i] + 1,  maxConsLib_i)))

S3_max = quicksum(s3_max[i, g] for i in I for g in G)
\end{lstlisting}


\subsection{Preferenze infermieri}
In questo vincolo \textit{soft} si cerca di soddisfare le richieste di permessi presentate da ciascun infermiere nella pianificazione dell'orario lavorativo, al contrario di richieste di ferie che non state prese in considerazione. In particolare, in questo vincolo, si penalizza l'assegnazione di un infermiere ad un turno indesiderato. Quindi la penalità complessiva da pagare nella funzione obbiettivo, in caso di insoddisfacibilità del vincolo, è data dalla somma di tutte le assegnazioni indesiderate.
Matematicamente si può scrivere come segue:

\begin{equation}
S^{(4)} = \sum_{(i, g, t) \in R} a_{i, t, g}
\end{equation}
dove:
\begin{itemize}
\item $S^{(4)}$: rappresenta la penalità complessiva da pagare nella funzione obbiettivo nel caso il vincolo non sia rispettato;
\item $R$: lista delle richieste fatte dagli infermieri dove sono specificati i giorni e i turni in cui ognuno di loro vorrebbe non lavorare.
\end{itemize}

Il codice Python corrispondente è il seguente:
\begin{lstlisting}[language=Python]
S4 = quicksum(a[i, t, g] for (i, g, t) in R)
\end{lstlisting}

\subsection{Week-end completo}
Il seguente vincolo \textit{soft} impone che ogni infermiere che deve ricoprire il proprio turno nel week-end, deve lavorare sia sabato che domenica. Nel caso lavorasse solo uno dei due giorni è necessario pagare una penalità. Si definiscono:
\begin{itemize}
\item $L_{i, g}^{!SAB}$: variabile binaria che tiene conto dei giorni in cui l'infermiere ha lavorato solo di di sabato, ovvero:
\begin{equation}
\label{eq:varLavoratoSoloSabato}
L_{i, g}^{!SAB}=
\begin{cases}
1, & \text{se l'infermiere i ha lavorato solo il sabato} \\
0, & \text{altrimenti.}
\end{cases}
\end{equation}
\item $L_{i, g}^{!DOM}$: variabile binaria che indica quali infermieri hanno lavorato solo la domenica, cioè:
\begin{equation}
\label{eq:varLavoratoSoloDomenica}
L_{i, g}^{!DOM}=
\begin{cases}
1, & \text{se l'infermiere i ha lavorato solo la domenica} \\
0, & \text{altrimenti.}
\end{cases}
\end{equation}
\item $S^{(5)}$: penalità da pagare nel caso gli infermieri a cui hanno assegnato il week-end completo abbiano lavorato solo il sabato o solo la domenica. 
\end{itemize}

Fissato l'infermiere $i$, e siano $g$ un qualunque sabato, e di conseguenza $g+1$ la corrispettiva domenica, i casi d'interesse sono quando l'infermiere ha lavorato soltanto uno dei due giorni. Quindi:
\begin{itemize}
\item [1)] se l'infermiere $i$ ha lavorato solo il sabato:
\begin{equation}
L_{i, g} = 1 \wedge L_{i, g+1} = 0 \Longrightarrow L_{i, g}^{!SAB} = 1 
\end{equation}
Che equivale a scrivere:
\begin{equation}
L_{i, g}^{!SAB} \geq L_{i, g} - L_{i, g+1}
\end{equation}

\item [2)] se l'infermiere $i$ ha lavorato solo la domenica:

\begin{equation}
L_{i, g+1} = 1 \wedge L_{i, g} = 0 \Longrightarrow L_{i, g}^{!DOM} = 1 
\end{equation}
Che equivale a scrivere:
\begin{equation}
L_{i, g}^{!DOM} \geq L_{i, g+1} - L_{i, g}
\end{equation}
\end{itemize}

Riassumendo:
\begin{equation}
\begin{split}
L_{i, g}^{!SAB} &\geq L_{i, g} - L_{i, g+1}  ~~~ \forall i \in I_{cw} ~~~ \forall g \in G_S \\
L_{i, g}^{!DOM} &\geq L_{i, g+1} - L_{i, g} ~~~ \forall i \in I_{cw} ~~~ \forall g \in G_S \\
S^{(5)} &= \sum_{i \in I_{cw}} \sum_{g \in G_S} L_{i, g}^{!SAB} + L_{i, g}^{!DOM} \\
\end{split}
\end{equation}

Il codice Python corrispondente è il seguente:
\begin{lstlisting}[language=Python]
Lsab = model.addVars(Icw, GS, vtype=GRB.BINARY)

Ldom = model.addVars(Icw, GS, vtype=GRB.BINARY)

model.addConstrs(Lsab[i, g] >= 
		(L[i, g] - L[i, g+1]) for i in Icw for g in GS)

model.addConstrs(Ldom[i, g] >= L[i, g+1] - L[i, g) 
		for i in Icw for g in GS)

S5 = quicksum(Lsab[i, g] + Ldom[i, g] 
		for i in Icw for g in GS)
\end{lstlisting}

\subsection{Assegnamenti totali}
Questo vincolo \textit{soft} ha l'obbiettivo di limitare il numero di assegnamenti totali fatti per ogni infermiere. Cioè, in altre parole, per ogni infermiere il numero totale dei giorni lavorativi deve essere compreso tra il minimo e il massimo previsti nel suo contratto. Le differenze, in entrambi i casi, vengono moltiplicate per i corrispettivi pesi nella funzione obbiettivo.
Siano:
\begin{itemize}
\item $minTotLav_i$: numero minimo di assegnamenti totali;
\item $maxTotLav_i$: numero massimo di assegnamenti totali;
\item $s^{(6)}_{i}$: penalità di ogni singolo infermiere;
\item $S^{(6)}$: penalità complessiva da pagare nel caso il vincolo non sia soddisfatto.
È data dalla somma di tutte le singole penalità.
\end{itemize}
L'idea di base è quella di penalizzare i casi in cui il numero totale di giorni lavorati sia minore del minimo o maggiore del massimo.
Quindi fissato l'infermiere $i$, analizziamo i due casi separatamente:
\begin{itemize}

\item [1)] \textit{Caso minimo}: se il totale degli assegnamenti fatti (ovvero dei giorni lavorati) è maggiore o uguale al minimo, la penalità $s^{(6)}_{i}$ che ogni infermiere deve pagare è nulla, mentre nel caso in cui il totale degli assegnamenti fatti sia minore del minimo richiesto la penalità è data dalla differenza tra il numero minimo e gli assegnamenti fatti. Fissato l'infermiere $i$, logicamente equivale a scrivere:
\begin{equation}
\begin{split}
\sum_{g \in G} L_{i, g} \geq minTotLav_i &\Longrightarrow s^{(6)}_{i} = 0 \\
\sum_{g \in G} L_{i, g} < minTotLav_i &\Longrightarrow s^{(6)}_{i} = minTotLav_i - \sum_{g \in G} L_{i, g} \\
\end{split}
\end{equation}
Sia $z_1 = minTotLav_i - \sum_{g \in G} L_{i, g}$, possiamo riscrivere:
\begin{equation}
\begin{split}
z_1 \leq 0 &\Longrightarrow s^{(6)}_{i} = 0 \\
z_1 > 0 &\Longrightarrow s^{(6)}_{i} = z_1 \\
\end{split}
\end{equation}
Da cui si può vedere che:
\begin{equation}
\label{eq:minS6}
s^{(6)}_{i} = max(0, z_1)
\end{equation}
Quindi, considerando che $s^{(6)}_{i}$ viene minimizzato nella funzione obbiettivo, per ottenere la (\ref{eq:minS6}) si impongono i seguenti vincoli:
\begin{equation}
\begin{split}
s^{(6)}_{i} &\geq 0 \\
s^{(6)}_{i} &\geq z_1 \\
\end{split}
\end{equation}
Pertanto è necessario imporre:
\begin{equation}
\begin{split}
s^{(6)}_{i} &\geq 0 \\
s^{(6)}_{i} &\geq minTotLav_i - \sum_{g \in G} L_{i, g} \\
\end{split}
\end{equation}

\item [2)] \textit{Caso massimo}: il ragionamento è analogo a quello sopra, con la differenza che stiamo controllando il valore massimo di assegnamenti. Quindi si dovrà pagare la penalità $s^{(6)}_{i}$ soltanto quando il numero di assegnamenti fatti è maggiore del numero massimo relativo, e viene definita dalla differenza tra queste due quantità. Fissato l'infermiere $i$, logicamente equivale a scrivere:
\begin{equation}
\begin{split}
\sum_{g \in G} L_{i, g} \leq maxTotLav_i &\Longrightarrow s^{(6)}_{i} = 0\\
\sum_{g \in G} L_{i, g} > maxTotLav_i &\Longrightarrow s^{(6)}_{i} = \sum_{g \in G} L_{i, g} - maxTotLav_i\\
\end{split}
\end{equation}
Sia $z_2 = \sum_{g \in G} aL_{i, g} - maxTotLav_i$, possiamo riscrivere:
\begin{equation}
\begin{split}
z_2 \leq 0 &\Longrightarrow s^{(6)}_{i} = 0 \\
z_2 > 0 &\Longrightarrow s^{(6)}_{i} = z_2 \\
\end{split}
\end{equation}
Da cui si può vedere che:
\begin{equation}
\label{eq:maxS6}
s^{(6)}_{i} = max(0, z_2)
\end{equation}
Quindi, considerando che $s^{(6)}_{i}$ viene minimizzato nella funzione obbiettivo, per ottenere la (\ref{eq:maxS6}) si impongono i seguenti vincoli:
\begin{equation}
\begin{split}
s^{(6)}_{i} &\geq 0 \\
s^{(6)}_{i} &\geq z_2 \\
\end{split}
\end{equation}
Pertanto è necessario imporre:
\begin{equation}
\begin{split}
s^{(6)}_{i} &\geq 0 \\
s^{(6)}_{i} &\geq \sum_{g \in G} L_{i, g} - maxTotLav_i \\
\end{split}
\end{equation}
\end{itemize}

Riassumendo possiamo scrivere:
\begin{equation}
\begin{split}
s^{(6)}_{i} &\geq 0 ~~~ \forall i \in I \\
s^{(6)}_{i} &\geq minTotLav_i - \sum_{g \in G} L_{i, g} ~~~ \forall i \in I \\
s^{(6)}_{i} &\geq \sum_{g \in G} L_{i, g} - maxTotLav_i  ~~~ \forall i \in I \\
S^{(6)} &= \sum_{i \in I} s^{(6)}_{i}
\end{split}
\end{equation}

Il codice Python corrispondente è il seguente:
\begin{lstlisting}[language=Python]
s6 = model.addVars(I, vtype=GRB.INTEGER)

model.addConstrs(s6[i] >= 0 for i in I)

model.addConstrs(s6[i] >= (minTotLav[i] - quicksum(L[i, g] 
		for g in G))
   	 	for i in I)
                        
model.addConstrs(s6[i] >= 
	(quicksum(L[i, g] for g in G) 
                        - maxTotLav[i]) for i in I)
                       			 
S6 = quicksum(s6[i] for i in I)
\end{lstlisting}


\subsection{Fine settimana totali lavorati}
Tale vincolo \textit{soft} impone che per ogni infermiere il numero di week-ends lavorativi deve essere minore o uguale al massimo. Il numero di week-ends lavorati in eccesso viene aggiunto alla funzione obbiettivo moltiplicato per il suo peso, dove un week-end è considerato lavorato se almeno uno dei due giorni l'infermiere ha svolto il suo turno. 
Si definiscono:
\begin{itemize}
\item $L_{i, g}^w$ è la variabile binaria definita come segue:
\begin{equation}
\label{eq:varLavoratoWeekEnd}
L_{i, g}^w=
\begin{cases}
1, & \text{se l'infermiere i ha lavorato almeno un giorno del week-end} \\
0, & \text{altrimenti.}
\end{cases}
\end{equation}
\item $maxTotWknd_i$: numero massimo di week-ends in cui l'infermiere può lavorare;
\item $s^{(7)}_i$: variabile intera che rappresenta la penalità che ogni infermiere deve pagare;
\item $S^{(7)}$: penalità complessiva da pagare nella funzione obbiettivo, data dalla somma di tutte le singole penalità $s^{(7)}_i$.
\end{itemize}

Per prima cosa è necessario accertarsi che, per fissato l'infermiere $i$ e il turno $t$, la variabile definita sopra, $L_{i, g}^w$, valga realmente 1 quando l'infermiere ha lavorato solo sabato o solo la domenica. Considerando un sabato qualunque $g$, possiamo scrivere:
\begin{equation}
\begin{split}
L_{i, g} = 1 &\Longrightarrow L_{i, g}^w = 1\\
L_{i, g+1} = 1 &\Longrightarrow L_{i, g}^w = 1\\
\end{split}
\end{equation}
Quindi questo equivale a dire:
\begin{equation}
\begin{split}
L_{i, g}^w &\geq L_{i, g}\\
L_{i, g}^w &\geq L_{i, g+1}\\
\end{split}
\end{equation}

Successivamente il ragionamento è simile ai vincoli già spiegati.
Cioè, è necessario pagare la penalità quando il numero di week-ends lavorati è maggiore del valore massimo. Quindi, fissato l'infermiere $i$, si ha:
\begin{equation}
\begin{split}
\sum_{g \in GS} L_{i, g}^w \leq maxTotWknd_i &\Longrightarrow s^{(7)}_{i} = 0\\
\sum_{g \in GS} L_{i, g}^w > maxTotWknd_i &\Longrightarrow s^{(7)}_{i} = \sum_{g \in GS} L_{i, g}^w - maxTotWknd_i\\
\end{split}
\end{equation}
Sia $se ~ z = \sum_{g \in GS} L_{i, g}^w - maxTotWknd_i$, possiamo riscrivere:
\begin{equation}
\begin{split}
z \leq 0 &\Longrightarrow s^{(7)}_{i} = 0\\
z > 0 &\Longrightarrow s^{(7)}_{i} = z\\
\end{split}
\end{equation}
Da cui si può vedere che:
\begin{equation}
\label{eq:maxS7}
s^{(7)}_{i} = max(0, z)
\end{equation}
E quindi:
\begin{equation}
\begin{split}
s^{(7)}_{i} \geq 0\\
s^{(7)}_{i} \geq z\\
\end{split}
\end{equation}
Pertanto è necessario imporre:
\begin{equation}
\begin{split}
s^{(7)}_{i} &\geq 0\\
s^{(7)}_{i} &\geq (\sum_{g \in GS} L_{i, g}^w ) - maxTotWknd_i
\end{split}
\end{equation}

Ricapitolando si ha:
\begin{equation}
\begin{split}
L_{i, g}^w &\geq L_{i, g} ~~~ \forall i \in I ~~~ \forall g \in GS \\
L_{i, g}^w &\geq L_{i, g+1} ~~~ \forall i \in I ~~~ \forall g \in GS \\
s^{(7)}_{i} &\geq 0  ~~~ \forall i \in I \\
s^{(7)}_{i} &\geq (\sum_{g \in GS} L_{i, g}^w ) - maxTotWknd_i ~~~ \forall i \in I \\
S^{(7)} &= \sum_{i \in I} s^{(7)}_{i} \\
\end{split}
\end{equation}

Il codice Python corrispondente è il seguente:
\begin{lstlisting}[language=Python]
Lw = model.addVars(I, GS, vtype=GRB.BINARY)

model.addConstrs(Lw[i, g] >= L[i, g] 
                for i in I
                for g in GS)

model.addConstrs(Lw[i, g] >= L[i, g+1] 
                for i in I
                for g in GS)

s7 = model.addVars(I, vtype=GRB.INTEGER)

model.addConstrs(s7[i] >= 0 for i in I)

model.addConstrs(s7[i] >= quicksum(Lw[i, g] for g in GS) 
                - maxTotWknd[i] for i in I)

S7 = quicksum(s7[i] for i in I)
\end{lstlisting}


\section{Funzione obbiettivo}
Lo scopo di questo programma è minimizzare la funzione obbiettivo, la quale è definita dalla somma delle penalità dei vincoli soft, moltiplicate dai \textit{pesi} corrispondenti $w_i$, che servono a calcolare il costo totale da pagare in caso alcuni di questi non vengano rispettati. Ovvero:
\begin{gather}
Obj = w_1 S^{(1)} + w_{2min} S^{(2)}_{min} + w_{2max} S^{(2)}_{max} + w_3 S^{(3)}_{min} + w_3 S^{(3)}_{max} + w_4 S^{(4)} + w_5 S^{(5)} + w_6 S^{(6)} + w_7 S^{(7)} 
\end{gather}

Il codice Python corrispondente è il seguente:
\begin{lstlisting}[language=Python]
obj = w1 * S1 + w2_min * S2_min + w2_max * S2_max + 
			w3 * (S3_min + S3_max) + w4 * S1 + w4 * S5 + 
				w6 * S6 + w7 * S7

model.setObjective(obj, GRB.MINIMIZE)

model.optimize()
\end{lstlisting}





